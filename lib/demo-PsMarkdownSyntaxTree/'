using MarkdownTree.Parse;
using System.Management.Automation;
using System.Text.RegularExpressions;

namespace PsMarkdownTree;

/*
 * Generated Keywords
 * - _LineType
 * - _Content
 * - _Completed
 * - Language
 * - Lines
 * - Children
 * - Table
 * - Value
 * - _MissingName
 */

[Cmdlet(
    VerbsCommon.Find, "MarkdownTree",
    DefaultParameterSetName = "ByPropertyName"
)]
public class FindMarktownTreeCommand : PSCmdlet
{
    public delegate bool Predicate(object obj);

    [Parameter(
        ValueFromPipeline = true,
        Position = 0
    )]
    // [Parameter(
    //     ParameterSetName = "ByPropertyName"
    // )]
    // [Parameter(
    //     ParameterSetName = "ByScriptBlock"
    // )]
    public object[] InputObject = [];

    [Parameter(
        Position = 1
    )]
    [Parameter(
        ParameterSetName = "ByScriptBlock"
    )]
    public Predicate? ScriptBlock;

    [Parameter(
        Position = 1
    )]
    [Parameter(
        ParameterSetName = "ByPropertyName"
    )]
    public string[] PropertyName = [];

    private static IEnumerable<PSObject>
    FindSubtree(PSObject psobject, Predicate predicate)
    {
        if (predicate(psobject))
            yield return psobject;

        foreach (var property in psobject.Properties)
            if (property.Value is PSObject subtree)
                foreach (var value in FindSubtree(subtree, predicate))
                    yield return value;
    }

    private static IEnumerable<object>
    FindSubtree(PSObject psobject, string[] propertyName)
    {
        foreach (var property in psobject.Properties)
            if (propertyName.Contains(property.Name))
            {
                yield return property.Value;

                if (property.Value is PSObject subtree)
                    foreach (var value in FindSubtree(subtree, propertyName))
                        yield return value;
            }
    }

    protected override void ProcessRecord()
    {
        switch (ParameterSetName)
        {
            case "ByPropertyName":
                foreach (var item in InputObject)
                {
                    var list = item switch
                    {
                        PSObject psobject => FindSubtree(psobject, PropertyName),

                        Branching root => root.WhereAll(x => x switch
                        {
                            Outline o => PropertyName.Contains(o.Name),
                            ITree t => PropertyName.Contains(t.ToString()?.Trim() ?? string.Empty),
                        }),

                        _ => [],
                    };

                    foreach (var subtree in list)
                        WriteObject(subtree);
                }

                break;
            case "ByScriptBlock":
                ScriptBlock ??= _ => true;

                foreach (object item in InputObject)
                {
                    IEnumerable<object> list = item switch
                    {
                        PSObject psobject => FindSubtree(psobject, ScriptBlock),
                        Branching root => root.WhereAll(x => ScriptBlock(x)),
                        _ => ScriptBlock(item) ? [item] : [],
                    };

                    foreach (var subtree in list)
                        WriteObject(subtree);
                }

                break;
        }
    }
}

[Cmdlet(VerbsCommunications.Write, "MarkdownTree")]
public class WriteMarkdownTreeCommand : Cmdlet
{
    [Parameter(
        ValueFromPipeline = true,
        Position = 0
    )]
    public object[] InputObject = [];

    protected void Write(IEnumerable<string> lines)
    {
        foreach (string line in lines)
            WriteObject(line);
    }

    protected void
    Write(
        PSObject tree,
        int indentSize = IMarkdownWritable.DEFAULT_INDENT_SIZE,
        int level = 0
    ) {
        string space = string.Empty;

        string box = tree.Properties.Any(p => p.Name == "_Completed")
            ? (bool)tree.Properties["_Completed"].Value
                ? "[x] "
                : "[ ] "
            : string.Empty;

        foreach (var prop in
            from p in tree.Properties
            where p.Name != "_Completed"
            select p
        ) {
            space = string.Concat(Enumerable.Repeat(" ", level * indentSize));
            WriteObject($"{space}- {box}{prop.Name}");
            space = string.Concat(Enumerable.Repeat(" ", (level + 1) * indentSize));

            if (prop.Value is PSObject branch)
                Write(branch, indentSize, level + 1);
            else if (prop.Value is string str)
                WriteObject($"{space}- {str}");
            else if (prop.Value is object[] list)
                foreach (var item in list)
                    WriteObject($"{space}- {item}");
        }
    }

    protected override void ProcessRecord()
    {
        base.ProcessRecord();

        foreach (object item in InputObject)
        {
            if (item is IMarkdownWritable tree)
            {
                Write(tree.ToMarkdown());
                continue;
            }

            if (item is PSObject psobject)
            {
                var collection = psobject
                    .Properties
                    .Where(p => p.Name == "_Content");

                if (collection.Any())
                    Write(psobject);
                else
                    foreach (var subitem in collection)
                        if (subitem.Value is IMarkdownWritable contentTree)
                            Write(contentTree.ToMarkdown());
                        else
                            Write([subitem.Value.ToString()?.Trim() ?? string.Empty]);
            }
        }
    }
}

[Cmdlet(VerbsCommon.Get, "MarkdownTree")]
public class GetMarkdownTreeCommand : Cmdlet
{
    [Parameter(
        ValueFromPipeline = true,
        Position = 0
    )]
    public string[] InputObject = [];

    [Parameter()]
    public SwitchParameter Full;

    [Parameter()]
    public SwitchParameter AsMarkdown;

    [Parameter()]
    public string[] MuteProperty = [];

    [Parameter()]
    public string[] MergeProperty = [];

    [Parameter()]
    public string[] FoldProperty = [];

    protected IList<string> _markdown = [];

    protected override void BeginProcessing()
    {
        base.BeginProcessing();
        _markdown = [];
    }

    protected override void ProcessRecord()
    {
        base.ProcessRecord();

        foreach (var item in InputObject)
            _markdown.Add(item);
    }

    protected override void EndProcessing()
    {
        base.EndProcessing();

        var forest = Outline.Get(_markdown, c => !MuteProperty.Contains(((Outline)c).Name));

        if (MergeProperty.Length > 0)
        {
            forest = Outline.Merge([.. forest], c => MergeProperty.Contains(((Outline)c).Name));

            forest =
                [.. from t in forest
                    where t is Outline
                    select ((Outline)t).CascadeMerge(c => MergeProperty.Contains(((Outline)c).Name))];
        }

        if (FoldProperty.Length > 0)
        {
            forest =
                from t in forest
                where t is Outline
                select ((Outline)t).Fold(c => FoldProperty.Contains(((Outline)c).Name));
        }

        foreach (var tree in forest)
        {
            ITree worktree = tree is Outline outline
                ? outline.CascadeFold().CascadeMerge()
                : tree;

            var obj = new PSObject();
            AddProperty(obj, worktree);
            WriteObject(obj);
        }
    }

    public const string MISSING_NAME_MESSAGE = "_MissingName";

    private void AddTreeProperty(PSObject obj, Branching tree, string propertyName)
    {
        PSObject subobj = new();

        foreach (ITree subtree in tree.Children)
            AddProperty(subobj, subtree);

        if (string.IsNullOrWhiteSpace(propertyName))
        {
            if (tree.Children.Count == 0)
                return;

            propertyName = MISSING_NAME_MESSAGE;
        }

        if (!obj.Properties.Any(p => p.Name == propertyName))
        {
            // branch
            obj.Members.Add(new PSNoteProperty(propertyName, subobj));
        }
        else
        {
            var value = obj.Properties[propertyName].Value;

            if (value is IList<object> list)
            {
                list.Add(subobj);
                obj.Properties[propertyName].Value = list;
            }
            else
            {
                IList<object> newList = [];
                newList.Add(value);
                newList.Add(subobj);
                obj.Properties[propertyName].Value = newList;
            }
        }
    }

    private void AddOutlineProperty(PSObject obj, Outline outline)
    {
        AddTreeProperty(obj, outline, outline.Name);
        obj.Properties.Add(new PSNoteProperty("_LineType", outline.LineType));
        obj.Properties.Add(new PSNoteProperty("_Content", outline.Content));
    }

    private static bool ConvertLeafToString(PSObject obj, Outline outline)
    {
        if (outline.Children.Count == 1)
        {
            var child = outline.Children[0];

            if (child is Branching p && p.Children.Count == 0)
            {
                string value = child is Outline o
                    ? o.Name
                    : child.ToString()?.Trim() ?? MISSING_NAME_MESSAGE;

                obj.Properties.Add(new PSNoteProperty(outline.Name, value));
                return true;
            }
            else if (child is ISegment s)
            {
                string value = s.ToString()?.Trim() ?? MISSING_NAME_MESSAGE;
                obj.Properties.Add(new PSNoteProperty(outline.Name, value));
                return true;
            }
        }

        return false;
    }

    private void AddProperty(PSObject obj, ITree tree)
    {
        if (tree is Outline outline)
        {
            if (ConvertLeafToString(obj, outline))
                return;

            if (Full.IsPresent)
                AddOutlineProperty(obj, outline);
            else
                AddTreeProperty(obj, outline, outline.Name);
        }

        if (tree is ActionItem actionItem)
        {
            obj.Properties.Add(new PSNoteProperty("_Completed", actionItem.Completed));
            return;
        }

        if (tree is CodeBlock codeBlock)
        {
            obj.Members.Add(new PSNoteProperty("Language", codeBlock.Language));
            obj.Members.Add(new PSNoteProperty("Lines", codeBlock.Lines));
            AddTreeProperty(obj, codeBlock, "Children");
            return;
        }

        if (tree is Table table)
        {
            var subobj = new PSObject();

            IList<string> headings =
                [.. from h in table.Headings
                    select h.ToString().Trim()];

            foreach (var row in table.Rows)
            {
                IList<string> cells =
                    [.. from c in row
                        select c.ToString().Trim()];

                for (int i = 0; i < headings.Count; ++i)
                    subobj.Members.Add(new PSNoteProperty(headings[i], cells[i]));
            }

            obj.Members.Add(new PSNoteProperty("Table", subobj));
            AddTreeProperty(obj, table, "Children");
            return;
        }

        if (tree is ISegment segment)
        {
            obj.Members.Add(new PSNoteProperty("Value", segment.ToString().Trim()));
            obj.Members.Add(new PSNoteProperty("_Content", segment));
        }
    }
}

